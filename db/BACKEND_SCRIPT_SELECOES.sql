USE BACKEND_PROJETO;

/* Mostra todos os dados de todos os produtos cadastrados */

SELECT * FROM XS_PRODUTO;

/* Mostra todos os dados de todos os fornecedores cadastrados */

SELECT * FROM XS_FORNECEDOR;

/* Mostra todos os dados de todos os depositos cadastrados */

SELECT * FROM XS_DEPOSITO;

/* View que mostra os depósito com todos os seus produtos cadastrados e pontos de reposição de cada produto */

CREATE VIEW DEPOSITO_PONTO_REP AS
SELECT DEPOSITO.NOME_DEPOSITO, DP.PONTO_REP_DEPOSITO, PRODUTO.NOME_PRODUTO
FROM XS_DEPOSITO_PRODUTO DP
JOIN XS_DEPOSITO DEPOSITO ON DP.ID_DEPOSITO = DEPOSITO.ID
JOIN XS_PRODUTO PRODUTO ON DP.ID_PRODUTO = PRODUTO.ID
ORDER BY DEPOSITO.NOME_DEPOSITO;

/* View que retorna o nome e a quantidade atual total dos produtos que estão abaixo do ponto de reposição geral cadastrado no sistema */

CREATE VIEW REPOSICAO_GERAL AS
SELECT PRODUTO.ID, PRODUTO.NOME_PRODUTO, (COALESCE(ENTRADA.SOMA_ENTRADAS, 0) - COALESCE(SAIDA.SOMA_SAIDAS, 0)) AS QTD_ATUAL
FROM XS_PRODUTO PRODUTO 
JOIN (SELECT ID_PRODUTO, SUM(QTD_MOVIMENTACAO) AS SOMA_ENTRADAS FROM XS_MOVIMENTACAO WHERE TIPO_MOVIMENTACAO IN (1,2,5) GROUP BY ID_PRODUTO) AS ENTRADA 
JOIN (SELECT ID_PRODUTO, SUM(QTD_MOVIMENTACAO) AS SOMA_SAIDAS FROM XS_MOVIMENTACAO WHERE TIPO_MOVIMENTACAO IN (3,4,6) GROUP BY ID_PRODUTO) AS SAIDA 
ON PRODUTO.ID = ENTRADA.ID_PRODUTO = SAIDA.ID_PRODUTO
WHERE ENTRADA.SOMA_ENTRADAS - SAIDA.SOMA_SAIDAS < PRODUTO.PONTO_REP_PRODUTO
ORDER BY PRODUTO.ID;

/* Procedure para buscar o nome dos fornecedores que possuem o item que está para reposição */

DELIMITER //

CREATE PROCEDURE BUSCA_FORNECEDOR(IN ID_ESCOLHIDO INT)
BEGIN
    SELECT DISTINCT FP.ID_PRODUTO, FORNECEDOR.NOME_FORNECEDOR
    FROM XS_FORNECEDOR FORNECEDOR
    JOIN XS_FORNECEDOR_PRODUTO FP ON FORNECEDOR.ID = FP.ID_FORNECEDOR
    WHERE FP.ID_PRODUTO IN ( SELECT ID FROM REPOSICAO_GERAL WHERE ID = ID_ESCOLHIDO);
END //

DELIMITER ;

/* View que retorna o nome do deposito, nome do produto e a quantidade atual de tal produto dentro do depósito relacionado
e que está abaixo do ponto de reposição desse depósito de acordo com o que foi cadastrado no sistema */

CREATE VIEW REPOSICAO_DEPOSITO AS
SELECT DEPOSITO.NOME_DEPOSITO, PRODUTO.NOME_PRODUTO, (COALESCE(ENTRADA.SOMA_ENTRADAS, 0) - COALESCE(SAIDA.SOMA_SAIDAS, 0)) AS QTD_ATUAL
FROM XS_PRODUTO AS PRODUTO 
JOIN XS_DEPOSITO_PRODUTO AS RELACAO ON PRODUTO.ID = RELACAO.ID_PRODUTO 
JOIN XS_DEPOSITO AS DEPOSITO ON DEPOSITO.ID = RELACAO.ID_DEPOSITO 
LEFT OUTER JOIN (SELECT ID_PRODUTO, ID_DEPOSITO, SUM(QTD_MOVIMENTACAO) AS SOMA_ENTRADAS FROM XS_MOVIMENTACAO WHERE TIPO_MOVIMENTACAO IN (1,2,5) GROUP BY ID_PRODUTO, ID_DEPOSITO) AS ENTRADA ON PRODUTO.ID = ENTRADA.ID_PRODUTO AND DEPOSITO.ID = ENTRADA.ID_DEPOSITO
LEFT OUTER JOIN (SELECT ID_PRODUTO, ID_DEPOSITO, SUM(QTD_MOVIMENTACAO) AS SOMA_SAIDAS FROM XS_MOVIMENTACAO WHERE TIPO_MOVIMENTACAO IN (3,4,6) GROUP BY ID_PRODUTO, ID_DEPOSITO) AS SAIDA ON PRODUTO.ID = SAIDA.ID_PRODUTO AND DEPOSITO.ID = SAIDA.ID_DEPOSITO
WHERE (COALESCE(ENTRADA.SOMA_ENTRADAS, 0) - COALESCE(SAIDA.SOMA_SAIDAS, 0)) < RELACAO.PONTO_REP_DEPOSITO;

/* View que conta cada produto, fornecedor e deposito distintos casdastrados no sistema, além de também contar o número de produtos distintos
que estão abaixo do ponto de reposição geral do sistema*/

CREATE VIEW DASHBOARD AS
SELECT COUNT(DISTINCT PRODUTO.id) AS TOTALPRODUTOS, COUNT(DISTINCT FORNECEDOR.id) AS TOTALFORNECEDOR, COUNT(DISTINCT DEPOSITO.id) AS TOTALDEPOSITO,
(SELECT COUNT(*) FROM REPOSICAO_GERAL) AS QTD_PRODUTO_REPOSICAO
FROM XS_PRODUTO PRODUTO, XS_FORNECEDOR FORNECEDOR, XS_DEPOSITO DEPOSITO;

/* View que retorna movimentação geral do estoque em ordem decrescente*/

CREATE VIEW MOVIMENTACAO_GERAL AS
SELECT MOVIMENTACAO.ID, MOVIMENTACAO.ID_PRODUTO, PRODUTO.NOME_PRODUTO, DEPOSITO.NOME_DEPOSITO, MOVIMENTACAO.PRECO_PRODUTO, MOVIMENTACAO.QTD_MOVIMENTACAO,
CASE
WHEN MOVIMENTACAO.TIPO_MOVIMENTACAO = 1 THEN 'ENTRADA POR NF'
WHEN MOVIMENTACAO.TIPO_MOVIMENTACAO = 2 THEN 'ENTRADA POR DOAÇÃO'
WHEN MOVIMENTACAO.TIPO_MOVIMENTACAO = 3 THEN 'SAIDA POR NF'
WHEN MOVIMENTACAO.TIPO_MOVIMENTACAO = 4 THEN 'SAIDA POR DOAÇÃO'
WHEN MOVIMENTACAO.TIPO_MOVIMENTACAO = 5 THEN 'TRANSFERÊNCIA - ENTRADA'
WHEN MOVIMENTACAO.TIPO_MOVIMENTACAO = 6 THEN 'TRANSFERÊNCIA - SAIDA'
ELSE 'MOVIMENTACAO NÃO RECONHECIDA'
END AS TIPO_MOVIMENTACAO 
FROM XS_MOVIMENTACAO MOVIMENTACAO
JOIN XS_PRODUTO PRODUTO ON MOVIMENTACAO.ID_PRODUTO = PRODUTO.ID
JOIN XS_DEPOSITO DEPOSITO ON MOVIMENTACAO.ID_DEPOSITO = DEPOSITO.ID
ORDER BY MOVIMENTACAO.ID DESC, MOVIMENTACAO.ID_PRODUTO, MOVIMENTACAO.ID_DEPOSITO;

/* Procedure que retorna movimentação de produto específico do estoque em ordem decrescente*/

DELIMITER //

CREATE PROCEDURE MOVIMENTACAO_PRODUTOS(IN ID_ESCOLHIDO INT)
BEGIN
    SELECT *
    FROM MOVIMENTACAO_GERAL
    WHERE ID_PRODUTO = ID_ESCOLHIDO;
END //

DELIMITER ;

/* Procedure que retorna a quantidade atual de cada produto e seu respectivo preço medio de acordo com o cálculo disponibilizado */

DELIMITER //

CREATE PROCEDURE QTD_PM_ATUAL()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE produto_id INT;
    DECLARE produto_nome VARCHAR(20);
    DECLARE qtd_movimentacao INT;
    DECLARE qtd_atual INT DEFAULT 0;
    DECLARE tipo_movimentacao INT;
    DECLARE preco_medio DECIMAL(6,2);
    DECLARE id INT DEFAULT 0;
	DECLARE pm DECIMAL(6,2) DEFAULT 0;
    
    DECLARE cur CURSOR FOR 
        SELECT MOVIMENTACAO.ID_PRODUTO, PRODUTO.NOME_PRODUTO, MOVIMENTACAO.QTD_MOVIMENTACAO, MOVIMENTACAO.TIPO_MOVIMENTACAO, MOVIMENTACAO.PRECO_PRODUTO
        FROM XS_MOVIMENTACAO MOVIMENTACAO
        JOIN XS_PRODUTO PRODUTO ON MOVIMENTACAO.ID_PRODUTO = PRODUTO.ID
        ORDER BY ID_PRODUTO ASC, TIPO_MOVIMENTACAO;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
	DROP TEMPORARY TABLE IF EXISTS TEMP_MOVIMENTACAO;
	
    CREATE TEMPORARY TABLE IF NOT EXISTS TEMP_MOVIMENTACAO (
        ID_PRODUTO INT PRIMARY KEY,
        NOME_PRODUTO VARCHAR(20),
        QTD INT,
        PRECOMEDIO DECIMAL(6,2)
    );
    
    OPEN cur;
    
    read_loop: LOOP
        FETCH cur INTO produto_id, produto_nome, qtd_movimentacao, tipo_movimentacao, preco_medio;
        
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        IF produto_id <> id THEN
            SET id = produto_id;
            SET qtd_atual = 0;
            SET pm = 0;
        END IF;

        IF tipo_movimentacao = 1 THEN
            SET qtd_atual = qtd_atual + qtd_movimentacao;
			IF pm <> 0 THEN
				SET pm = ((pm*qtd_atual)+(preco_medio*qtd_movimentacao))/(qtd_atual+qtd_movimentacao);
			ELSE
				SET pm = preco_medio;
			END IF;
        ELSEIF tipo_movimentacao IN (2, 5) THEN
			SET qtd_atual = qtd_atual + qtd_movimentacao;
        ELSE
            SET qtd_atual = qtd_atual - qtd_movimentacao;
        END IF;
        
        INSERT INTO TEMP_MOVIMENTACAO (ID_PRODUTO, NOME_PRODUTO, QTD, PRECOMEDIO)
        VALUES (produto_id, produto_nome, qtd_atual, pm)
        ON DUPLICATE KEY UPDATE QTD = qtd_atual, PRECOMEDIO = pm;
        
    END LOOP;
    
    CLOSE cur;
    
    SELECT *  FROM TEMP_MOVIMENTACAO;
    
END //

DELIMITER ;


SELECT * FROM DEPOSITO_PONTO_REP;

SELECT * FROM REPOSICAO_GERAL;

SELECT * FROM REPOSICAO_DEPOSITO;

SELECT * FROM DASHBOARD;

SELECT * FROM MOVIMENTACAO_GERAL;

CALL BUSCA_FORNECEDOR(3);

CALL MOVIMENTACAO_PRODUTOS(1);

CALL QTD_PM_ATUAL();
